🔍 1. خوارزميات البحث (Searching Algorithms)
📌 الخوارزمية: Linear Search (البحث الخطي)

🛠 لماذا تستخدم: للبحث عن عنصر في مصفوفة أو قائمة غير مرتبة.
⚙️ طريقة العمل: تفحص العناصر واحدًا تلو الآخر حتى تجد العنصر المطلوب أو تنتهي القائمة.

function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i; // وجد العنصر
  }
  return -1; // لم يتم العثور
}
console.log(linearSearch([5, 2, 8, 4], 8)); // 2

📌 الخوارزمية: Binary Search (البحث الثنائي)

🛠 لماذا تستخدم: للبحث السريع في قوائم مرتبة.
⚙️ طريقة العمل: تقسيم المصفوفة نصفين في كل خطوة، مقارنة العنصر في المنتصف مع الهدف.

function binarySearch(arr, target) {
  let left = 0, right = arr.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}
console.log(binarySearch([1, 3, 5, 7, 9], 7)); // 3

📊 2. خوارزميات الترتيب (Sorting Algorithms)
📌 الخوارزمية: Bubble Sort (الترتيب بالفقاعات)

🛠 لماذا تستخدم: لترتيب العناصر (تصاعديًا أو تنازليًا).
⚙️ طريقة العمل: تمرير متكرر على المصفوفة، تبديل العناصر المتجاورة إذا كانت في ترتيب خاطئ.

function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j+1]) [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
    }
  }
  return arr;
}
console.log(bubbleSort([4, 3, 1, 5])); // [1, 3, 4, 5]

📌 الخوارزمية: Quick Sort (الترتيب السريع)

🛠 لماذا تستخدم: لترتيب عناصر بكفاءة عالية خاصة مع البيانات الكبيرة.
⚙️ طريقة العمل: اختيار عنصر كمحور (pivot)، تقسيم العناصر لليسار والأيمن، ثم تكرار العملية بشكل متكرر.

function quickSort(arr) {
  if (arr.length <= 1) return arr;
  let pivot = arr[arr.length - 1];
  let left = [], right = [];
  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }
  return [...quickSort(left), pivot, ...quickSort(right)];
}
console.log(quickSort([4, 3, 1, 5])); // [1, 3, 4, 5]

🔄 3. البرمجة الديناميكية (Dynamic Programming)
📌 الخوارزمية: Fibonacci with Memoization (متتالية فيبوناتشي)

🛠 لماذا تستخدم: لحساب القيم المتكررة بكفاءة عبر الحفظ (Memoization).
⚙️ طريقة العمل: حفظ النتائج المحسوبة سابقًا في جدول لتجنب الحساب المتكرر.

function fib(n, memo = {}) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  memo[n] = fib(n-1, memo) + fib(n-2, memo);
  return memo[n];
}
console.log(fib(10)); // 55

📌 الخوارزمية: 0/1 Knapsack Problem (حقيبة الظهر)

🛠 لماذا تستخدم: لاختيار عناصر ذات قيم وأوزان بحيث تعظم القيمة الكلية دون تجاوز السعة.
⚙️ طريقة العمل: استخدام جدول DP لتخزين أفضل الحلول الجزئية لكل وزن وسعة.

function knapsack(weights, values, W) {
  let n = weights.length;
  let dp = Array(n+1).fill().map(() => Array(W+1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= W; w++) {
      if (weights[i-1] <= w)
        dp[i][w] = Math.max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w]);
      else
        dp[i][w] = dp[i-1][w];
    }
  }
  return dp[n][W];
}
console.log(knapsack([1,2,3], [10,15,40], 5)); // 55
